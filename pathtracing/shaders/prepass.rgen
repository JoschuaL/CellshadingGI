#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_nonuniform_qualifier : enable
#include "random.glsl"
#include "raycommon.glsl"
#include "wavefront.glsl"

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba32f) uniform image2D image;
layout(binding = 2, set = 0, rgba32f) uniform image2D normalImage;
layout(binding = 3, set = 0, rgba32f) uniform image2D depthImage;
layout(binding = 4, set = 0, rgba32f) uniform image2D idImage;

layout(binding = 5, set = 1, scalar) buffer Vertices
{
  Vertex v[];
}
vertices[];


layout(binding = 6, set = 1) buffer Indices
{
  uint i[];
}
indices[];


layout(binding = 9, set = 1) buffer CelInfo
{
  celinfo i[];
}
CelInfos[];


layout(location = 0) rayPayloadEXT hitPayload prd;
layout(location = 1) rayPayloadEXT bool isShadowed;

layout(binding = 0, set = 1) uniform CameraProperties
{
  mat4 view;
  mat4 proj;
  mat4 viewInverse;
  mat4 projInverse;
}
cam;

layout(binding = 8, set = 1) buffer PointLightsBuffer
{
  PointLight l[];
}
plights;

layout(push_constant) uniform Constants
{
  vec4  clearColor;
  vec4  lightColor;
  vec4  lightPosition;
  int   numObjs;
  int   numAreaSamples;
  int   frame;
  int   numSamples;
  float fuzzyAngle;
  float ior;
  int   numAreaLights;
  int   maxBounces;
  float maxRussian;
  int   numPointLights;
  int   numIds;
  int   celsteps;
  float celramp;
  float r;
  float cut;
  float maxillum;
  int   obid;
  int   pass;
  int   offset;
}
pushC;


const float gaussian_k[25] = {0.024, 0.034, 0.038, 0.034, 0.024, 0.034, 0.049, 0.055, 0.049,
                              0.034, 0.038, 0.055, 0.063, 0.055, 0.038, 0.034, 0.049, 0.055,
                              0.049, 0.034, 0.024, 0.034, 0.038, 0.034, 0.024};


const float sobel_x[9] = {1, 0, -1, 2, 0, -2, 1, 0, -1};

const float sobel_y[9] = {1, 2, 1, 0, 0, 0, -1, -2, -1};

const float just_scalingx[9] = {0, 0, 0, -1, 0, 1, 0, 0, 0};

const float just_scalingy[9] = {0, -1, 0, 0, 0, 0, 0, 1, 0};

void main()
{

  uint xpos = gl_LaunchIDEXT.x;
  uint ypos = gl_LaunchIDEXT.y;

  uint mask = 0;
  // Initialize the random number
  prd.seed       = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, pushC.frame);
  vec3 hitValues = vec3(0);


  const ivec3 ind = ivec3(indices[nonuniformEXT(pushC.obid)].i[xpos - (xpos % 3) + 0],  //
                          indices[nonuniformEXT(pushC.obid)].i[xpos - (xpos % 3) + 1],  //
                          indices[nonuniformEXT(pushC.obid)].i[xpos - (xpos % 3) + 2]);

  const Vertex[3] v = Vertex[3](vertices[nonuniformEXT(pushC.obid)].v[ind.x],
                                vertices[nonuniformEXT(pushC.obid)].v[ind.y],
                                vertices[nonuniformEXT(pushC.obid)].v[ind.z]);


  // Subpixel jitter: send the ray through a different position inside the pixel
  // each time, to provide antialiasing.

  vec3 normal = normalize(cross(v[1].pos - v[0].pos, v[2].pos - v[0].pos));
  vec3 origin = v[xpos % 3].pos;

  float r    = 33.0;
  int   rint = 33;
  float ur   = (pushC.frame % rint) / r;
  float vr   = float(int(pushC.frame / rint)) / r;
  ur         = min(max(0, ur), 1);
  vr         = min(max(0, vr), 1);

  const LocalCoords locale      = gen_local_coords(normal);
  vec3              ogdirection = sample_cosine_hemisphere_direct(locale, ur, vr);
  vec3              direction   = ogdirection;

  uint  rayFlags = gl_RayFlagsOpaqueEXT;
  float tMin     = 0.001;
  float tMax     = 10000.0;


  prd.done          = false;
  prd.weight        = vec3(1, 1, 1);
  prd.last_bsdf_pdf = 1.0;
  prd.specular      = true;
  prd.first         = true;
  prd.needsSampling = false;

  prd.color = vec3(0, 0, 0);


  if(pushC.frame == 1)
  {
    vec3  maxL = vec3(0);
    float maxi = 0;
    for(int i = 0; i < pushC.numPointLights; i++)
    {
      PointLight li = plights.l[i];


      vec3 pos = li.pos.xyz;

      vec3  ldir        = pos - origin;
      float dist        = length(ldir);
      vec3  L           = normalize(ldir);
      float outanglecos = dot(L, normal);

      if(outanglecos < 0)
      {
        //continue;
      }

      vec3 col = li.color.xyz / (dist * dist);
      if(col.x + col.y + col.z <= 0)
      {
        continue;
      }


      uint direct_flags = gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT
                          | gl_RayFlagsSkipClosestHitShaderEXT;
      isShadowed = true;
      traceRayEXT(topLevelAS, direct_flags, 0xFF, 0, 0, 1, origin, tMin, L, dist, 1);
      if(isShadowed)
      {
        continue;
      }


      if(maxi < col.x + col.y + col.z)
      {
        maxi = col.x + col.y + col.z;
        maxL = L;
      }


      if(CelInfos[nonuniformEXT(pushC.obid)].i[xpos].max.w < col.x + col.y + col.z)
      {
        CelInfos[nonuniformEXT(pushC.obid)].i[xpos].max.w   = col.x + col.y + col.z;
        CelInfos[nonuniformEXT(pushC.obid)].i[xpos].max.xyz = L;
      }

      if(CelInfos[nonuniformEXT(pushC.obid)].i[xpos].min.w > col.x + col.y + col.z)
      {
        CelInfos[nonuniformEXT(pushC.obid)].i[xpos].min.w   = col.x + col.y + col.z;
        CelInfos[nonuniformEXT(pushC.obid)].i[xpos].min.xyz = L;
      }
      if(i > 0)
      {
        const float a         = 1.0f / float(i + 1);
        const vec3  old_color = CelInfos[nonuniformEXT(pushC.obid)].i[xpos].avg.xyz;
        CelInfos[nonuniformEXT(pushC.obid)].i[xpos].avg.xyz = mix(old_color, col, a);
      }
      else
      {
        CelInfos[nonuniformEXT(pushC.obid)].i[xpos].avg = vec4(col, 1);
        // First frame, replace the value in the buffer
      }
    }
  }
  else
  {


    for(int i = 0; i <= 32 && !prd.done; i++)
    {
      traceRayEXT(topLevelAS,  // acceleration structure
                  rayFlags,    // rayFlags
                  0xFF,        // cullMask
                  0,           // sbtRecordOffset
                  0,           // sbtRecordStride
                  0,           // missIndex
                  origin,      // ray origin
                  tMin,        // ray min range
                  direction,   // ray direction
                  tMax,        // ray max range
                  0            // payload (location = 0)
      );


      origin    = prd.rayOrigin;
      direction = prd.rayDirection;
    }


    if(CelInfos[nonuniformEXT(pushC.obid)].i[xpos].max.w < prd.color.x + prd.color.y + prd.color.z)
    {
      CelInfos[nonuniformEXT(pushC.obid)].i[xpos].max.w   = prd.color.x + prd.color.y + prd.color.z;
      CelInfos[nonuniformEXT(pushC.obid)].i[xpos].max.xyz = ogdirection;
    }

    if(CelInfos[nonuniformEXT(pushC.obid)].i[xpos].min.w > prd.color.x + prd.color.y + prd.color.z)
    {
      CelInfos[nonuniformEXT(pushC.obid)].i[xpos].min.w   = prd.color.x + prd.color.y + prd.color.z;
      CelInfos[nonuniformEXT(pushC.obid)].i[xpos].min.xyz = ogdirection;
    }
    if(pushC.frame > 0)
    {
      const float a         = 1.0f / float(pushC.frame + pushC.numPointLights + 1);
      const vec3  old_color = CelInfos[nonuniformEXT(pushC.obid)].i[xpos].avg.xyz;
      CelInfos[nonuniformEXT(pushC.obid)].i[xpos].avg.xyz = mix(old_color, prd.color, a);
    }
    else
    {
      CelInfos[nonuniformEXT(pushC.obid)].i[xpos].avg = vec4(prd.color, 1);
      // First frame, replace the value in the buffer
    }
  }

  uint x = (xpos - pushC.offset) % 1920;
  uint y = (xpos - pushC.offset) / 1920;
  for(int i = 0; i < 1080; i++)
  {
    if(x >= 0 && x < 1920 && y == 0)
    {
      float cel =
          ceil(dot(CelInfos[nonuniformEXT(pushC.obid)].i[xpos].max.xyz, normal) * pushC.celsteps)
          / pushC.celsteps;
      if(cel < pushC.celramp)
      {
        cel = 0.3;
      }
      else
      {
        cel = cel;
      }
      float c   = (ceil(abs(dot(CelInfos[nonuniformEXT(pushC.obid)].i[xpos].max.xyz, normal))
                      * pushC.celsteps)
                 / pushC.celsteps);
      vec3  col = c < pushC.celramp ? vec3(1, 0, 0) : vec3(0, 1, 0);
    }
  }


  return;
}
