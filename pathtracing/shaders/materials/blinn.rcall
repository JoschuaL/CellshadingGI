#version 460 core
#extension GL_EXT_ray_tracing : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#include "../random.glsl"
#include "../raycommon.glsl"
#include "../wavefront.glsl"

layout(location = 0) callableDataInEXT materialCall mc;

layout(binding = 1, set = 1, scalar) buffer MatColorBufferObject
{
  WaveFrontMaterial m[];
}
materials[];

layout(binding = 2, set = 1, scalar) buffer ScnDesc
{
  sceneDesc i[];
}
scnDesc;

layout(binding = 3, set = 1) uniform sampler2D textureSamplers[];
layout(binding = 4, set = 1) buffer MatIndexColorBuffer
{
  int i[];
}
matIndex[];

layout(push_constant) uniform Constants
{
  vec4  clearColor;
  vec3  lightPosition;
  float lightIntensity;
  vec3  lightDirection;
  float lightSpotCutoff;
  float lightSpotOuterCutoff;
  int   lightType;
};

float reflect_cosine(vec3 inDir, vec3 n, vec3 outDir)
{
  return max(dot(inDir, reflect(outDir, n)), 0.0);
}

void main()
{


  const int               matIdx = matIndex[nonuniformEXT(mc.objId)].i[mc.pId];
  const WaveFrontMaterial mat    = materials[nonuniformEXT(mc.objId)].m[matIdx];
  mc.eval_color = mat.specular * pow(reflect_cosine(mc.inDir, mc.normal, mc.outDir), mat.shininess);


  const LocalCoords coords = gen_local_coords(mc.normal);
  sample_cosine_power_hemisphere(coords, mat.shininess, rnd(mc.seed), rnd(mc.seed), mc);
  float p = reflect_cosine(mc.sample_in, mc.normal, mc.outDir);
  make_sample(mc.sample_in, mc.sample_pdf,
              mat.specular * (max(dot(mc.sample_in, mc.normal), 0.0) * pow(p, mat.shininess)),
              mc.normal, mc);


  mc.pdf_pdf =
      cosine_power_hemisphere_pdf(reflect_cosine(mc.inDir, mc.normal, mc.outDir), mat.shininess);
}