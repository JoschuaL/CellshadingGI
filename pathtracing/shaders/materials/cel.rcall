#version 460 core
#extension GL_EXT_ray_tracing : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#include "../random.glsl"
#include "../raycommon.glsl"
#include "../wavefront.glsl"

layout(location = 0) callableDataInEXT materialCall mc;

layout(binding = 1, set = 1, scalar) buffer MatColorBufferObject
{
  WaveFrontMaterial m[];
}
materials[];

layout(binding = 2, set = 1, scalar) buffer ScnDesc
{
  sceneDesc i[];
}
scnDesc;

layout(binding = 3, set = 1) uniform sampler2D textureSamplers[];
layout(binding = 4, set = 1) buffer MatIndexColorBuffer
{
  int i[];
}
matIndex[];

layout(push_constant) uniform Constants
{
  vec4  clearColor;
  vec4  lightColor;
  vec4  lightPosition;
  int   numObjs;
  int   numAreaSamples;
  int   frame;
  int   numSamples;
  float fuzzyAngle;
  float ior;
  int   numAreaLights;
  int   maxBounces;
  float maxRussian;
  int   numPointLights;
  int   numIds;
  int   celsteps;
  float celramp;
}
pushC;

void main()
{

  const int               matIdx   = matIndex[nonuniformEXT(mc.objId)].i[mc.pId];
  const WaveFrontMaterial mat      = materials[nonuniformEXT(mc.objId)].m[matIdx];
  uint                    txtId    = 0;
  vec3                    diffuse  = mat.diffuse;
  int                     celsteps = pushC.celsteps;
  float                   celramp  = pushC.celramp;

  if(mat.textureId >= 0)
  {
    txtId = mat.textureId + scnDesc.i[mc.instID].txtOffset;
    diffuse *= texture(textureSamplers[nonuniformEXT(txtId)], mc.texCoord).xyz;
  }

  float cellfac_eval = ceil(abs(dot(mc.normal, mc.inDir)) * celsteps) / celsteps;
  cellfac_eval       = max(step(celramp, cellfac_eval) * 1, .3);

  //mc.celfaccounter = max(cellfac,mc.celfaccounter);
  //mc.celradiance += mc.inR;
  //mc.celcounter += 1;

  //mc.outR += mc.inR * diffuse * mc.celfaccounter;

  mc.eval_color = diffuse * cellfac_eval / M_PI;
  //mc.eval_color = vec3(0);

  const LocalCoords coords = gen_local_coords(mc.normal);
  sample_cosine_hemisphere(coords, rnd(mc.seed), rnd(mc.seed), mc);

  float cellfac_sample = ceil(abs(dot(mc.sample_in, mc.normal)) * celsteps) / celsteps;
  cellfac_sample       = max(step(celramp, cellfac_sample), 0.3);

  const vec3 color = diffuse * cellfac_sample;

  make_sample(mc.sample_in, mc.sample_pdf, color, mc.normal, mc);
  mc.pdf_pdf = dot(mc.inDir, mc.normal) / M_PI;
}