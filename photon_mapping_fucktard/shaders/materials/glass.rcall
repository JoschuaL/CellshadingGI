#version 460 core
#extension GL_EXT_ray_tracing : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#include "../random.glsl"
#include "../raycommon.glsl"
#include "../wavefront.glsl"

layout(location = 0) callableDataInEXT materialCall mc;

layout(binding = 1, set = 1, scalar) buffer MatColorBufferObject
{
  WaveFrontMaterial m[];
}
materials[];

layout(binding = 2, set = 1, scalar) buffer ScnDesc
{
  sceneDesc i[];
}
scnDesc;

layout(binding = 3, set = 1) uniform sampler2D textureSamplers[];
layout(binding = 4, set = 1) buffer MatIndexColorBuffer
{
  int i[];
}
matIndex[];

layout(push_constant) uniform Constants
{
  vec4  clearColor;
  vec3  lightPosition;
  float lightIntensity;
  vec3  lightDirection;
  float lightSpotCutoff;
  float lightSpotOuterCutoff;
  int   lightType;
};


float fresnel(const vec3 indir, const vec3 normal, const float eta)
{
  float cosinangle = max(-1.0f, min(1.0f, dot(indir, normal)));
  float etaIn, etaNext;
  if(cosinangle > 0)
  {
    etaIn   = eta;
    etaNext = 1;
  }
  else
  {
    etaIn   = 1;
    etaNext = eta;
  }

  float sinteg = etaIn / etaNext * sqrt(max(0.f, 1 - cosinangle * cosinangle));
  if(sinteg >= 1)
  {
    return 1;
  }
  else
  {
    float cost = sqrt(max(0.f, 1 - sinteg * sinteg));
    cosinangle = abs(cosinangle);
    float Rs =
        ((etaNext * cosinangle) - (etaIn * cost)) / ((etaNext * cosinangle) + (etaIn * cost));
    float Rp =
        ((etaIn * cosinangle) - (etaNext * cost)) / ((etaIn * cosinangle) + (etaNext * cost));
    return (Rs * Rs + Rp * Rp) / 2;
  }
}

float fresnel_factor(float k, float cos_i, float cos_t)
{
  float R_s = (k * cos_i - cos_t) / (k * cos_i + cos_t);
  float R_p = (cos_i - k * cos_t) / (cos_i + k * cos_t);
  return (R_s * R_s + R_p * R_p) * 0.5f;
}

void main()
{
  mc.eval_color = vec3(0);
  mc.pdf_pdf    = 1.0;


  int               matIdx = matIndex[nonuniformEXT(mc.objId)].i[mc.pId];
  WaveFrontMaterial mat    = materials[nonuniformEXT(mc.objId)].m[matIdx];
  float             ior    = mc.ior;
  float             F      = 1.0;
  float             eta    = 1.0 / ior;
  float             cos_i  = (dot(mc.outDir, mc.normal));
  float             k      = eta;
  float             cos2_t = (1.0f - k * k * (1.0f - cos_i * cos_i));
  if(cos2_t > 0)
  {
    // Refraction
    float cos_t = sqrt(cos2_t);
    F           = fresnel_factor(k, cos_i, cos_t);
    if(rnd(mc.seed) > F)
    {
      vec3  t            = normalize((k * cos_i - cos_t) * mc.normal - k * mc.outDir);
      float adjoint_term = k * k;
      make_sample(t, 1.0f, mat.specular * adjoint_term, mc.normal, mc);
      return;
    }
  }
  make_sample(reflect(mc.outDir, mc.normal), 1.0f, mat.specular, mc.normal, mc);
}
