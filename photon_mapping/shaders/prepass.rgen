#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable
#include "random.glsl"
#include "raycommon.glsl"

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba32f) uniform image2D image;
layout(binding = 2, set = 0, rgba32f) uniform image2D normalImage;
layout(binding = 3, set = 0, rgba32f) uniform image2D depthImage;
layout(binding = 4, set = 0, rgba32f) uniform image2D idImage;
layout(binding = 7, set = 1) buffer AreaLightsBuffer
{
  AreaLight l[];
}
alights;

layout(binding = 8, set = 1) buffer PointLightsBuffer
{
  PointLight l[];
}
plights;

layout(binding = 9, set = 1) buffer PhotonInfo
{
  Photon p[];
}
Photons;


layout(location = 0) rayPayloadEXT photonPayload prd;

layout(binding = 0, set = 1) uniform CameraProperties
{
  mat4 view;
  mat4 proj;
  mat4 viewInverse;
  mat4 projInverse;
}
cam;

layout(push_constant) uniform Constants
{
  vec4  clearColor;
  vec4  lightColor;
  vec4  lightPosition;
  int   numObjs;
  int   numAreaSamples;
  int   frame;
  int   numSamples;
  float fuzzyAngle;
  float ior;
  int   numAreaLights;
  int   maxBounces;
  float maxRussian;
  int   numPointLights;
  int   numIds;
  int   celsteps;
  float celramp;
  float r;
  float cut;
  float maxillum;
  int   obid;
  int   pass;
  int   width;
}
pushC;

float uniform_sphere_pdf()
{
  return 1.0f / (4.0f * M_PI);
}


DirSample sample_uniform_sphere(float u, float v)
{
  const float c   = 2.0f * v - 1.0f;
  const float s   = sqrt(1.0f - c * c);
  const float phi = 2.0f * M_PI * u;
  const float x   = s * cos(phi);
  const float y   = s * sin(phi);
  const float z   = c;
  return DirSample(vec3(x, y, z), uniform_sphere_pdf());
}

struct EmissionSample
{
  vec3  pos;
  vec3  dir;
  vec3  intensity;
  float pdf_area;
  float pdf_dir;
  float cosv;
};

EmissionSample make_emission_sample(vec3  pos,
                                    vec3  dir,
                                    vec3  intensity,
                                    float pdf_area,
                                    float pdf_dir,
                                    float cosv)
{
  return pdf_area > 0 && pdf_dir > 0 && cosv > 0 ?
             EmissionSample(pos, dir, intensity, pdf_area, pdf_dir, cosv) :
             EmissionSample(pos, dir, vec3(0.0f), 1.0f, 1.0f, 1.0f);
}


const float gaussian_k[25] = {0.024, 0.034, 0.038, 0.034, 0.024, 0.034, 0.049, 0.055, 0.049,
                              0.034, 0.038, 0.055, 0.063, 0.055, 0.038, 0.034, 0.049, 0.055,
                              0.049, 0.034, 0.024, 0.034, 0.038, 0.034, 0.024};


const float sobel_x[9] = {1, 0, -1, 2, 0, -2, 1, 0, -1};

const float sobel_y[9] = {1, 2, 1, 0, 0, 0, -1, -2, -1};

const float just_scalingx[9] = {0, 0, 0, -1, 0, 1, 0, 0, 0};

const float just_scalingy[9] = {0, -1, 0, 0, 0, 0, 0, 1, 0};

void main()
{

  uint xpos = gl_LaunchIDEXT.x;
  uint ypos = gl_LaunchIDEXT.y;


  uint mask = 0;
  // Initialize the random number
  prd.seed       = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, pushC.frame);
  vec3 hitValues = vec3(0);


  int lightsample = int(min(rnd(prd.seed) * (pushC.numAreaLights + pushC.numPointLights),
                            pushC.numAreaLights + pushC.numPointLights - 1));


  EmissionSample es;

  if(lightsample < pushC.numAreaLights)
  {
    AreaLight al  = alights.l[lightsample];
    vec3      pos = al.v0.xyz + rnd(prd.seed) * (al.v1.xyz - al.v0.xyz)
               + rnd(prd.seed) * (al.v2.xyz - al.v0.xyz);
    vec3  nrm = (cross(al.v1.xyz - al.v0.xyz, al.v2.xyz - al.v0.xyz));
    float len = length(nrm);
    nrm       = normalize(nrm);
    pos       = offset_ray(pos, nrm);

    DirSample s =
        sample_cosine_hemisphere_direct(gen_local_coords(nrm), rnd(prd.seed), rnd(prd.seed));
    es = make_emission_sample(pos, s.dir, al.color.xyz, 1.0 / (len * 0.5), s.pdf, dot(s.dir, nrm));
  }
  else
  {
    PointLight li = plights.l[lightsample - pushC.numAreaLights];
    DirSample  s  = sample_uniform_sphere(rnd(prd.seed), rnd(prd.seed));
    es            = make_emission_sample(li.pos.xyz, s.dir, li.color.xyz, 1.0f, s.pdf, 1.0f);
  }


  vec3 origin = es.pos;

  vec3  direction = es.dir;
  float pdf       = es.pdf_area * es.pdf_dir;
  vec3  color     = (pushC.numAreaLights + pushC.numPointLights) * es.intensity * es.cosv / pdf;


  uint  rayFlags = gl_RayFlagsOpaqueEXT;
  float tMin     = 0.001;
  float tMax     = 10000.0;


  prd.done    = false;
  prd.color   = color;
  prd.emplace = false;


  // Initialize the random number


  /*const float r1 = rnd(prd.seed);
  const float r2 = rnd(prd.seed);
  // Subpixel jitter: send the ray through a different position inside the pixel
  // each time, to provide antialiasing.
  const vec2 subpixel_jitter = pushC.frame == 0 ? vec2(0.5f, 0.5f) : vec2(r1, r2);

  const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + subpixel_jitter;
  const vec2 inUV        = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
  const vec2 d           = inUV * 2.0 - 1.0;

  vec4 origin    = cam.viewInverse * vec4(0, 0, 0, 1);
  vec4 target    = cam.projInverse * vec4(d.x, d.y, 1, 1);*/


  for(int i = 0; i <= 32 && !prd.done; i++)
  {
    prd.emplace = false;
    color       = prd.color;
    traceRayEXT(topLevelAS,     // acceleration structure
                rayFlags,       // rayFlags
                0xFF,           // cullMask
                0,              // sbtRecordOffset
                0,              // sbtRecordStride
                3,              // missIndex
                origin.xyz,     // ray origin
                tMin,           // ray min range
                direction.xyz,  // ray direction
                tMax,           // ray max range
                0               // payload (location = 0)
    );
    if(prd.emplace)
    {
      Photons.p[xpos * 32 + i] = Photon(vec4(prd.rayOrigin, intBitsToFloat(1)), vec4(prd.gnrm, 1),
                                        vec4(prd.snrm, 1), vec4(direction.xyz, 1), vec4(color, 1));
    }
    //Photons.p[ypos * pushC.width + xpos + i] = Photon();
    origin.xyz    = prd.rayOrigin;
    direction.xyz = prd.rayDirection;
  }
  for(int i = 0; i < 1080; i++)
  {
    imageStore(image, ivec2(gl_LaunchIDEXT.x, i),
               vec4(Photons.p[xpos * 32 + (i % 32)].color.xyz, 1.f));
  }
}
