#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable
#include "random.glsl"
#include "raycommon.glsl"

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba32f) uniform image2D image;
layout(binding = 2, set = 0, rgba32f) uniform image2D normalImage;
layout(binding = 3, set = 0, rgba32f) uniform image2D depthImage;
layout(binding = 4, set = 0, rgba32f) uniform image2D idImage;


layout(location = 0) rayPayloadEXT hitPayload prd;
layout(location = 1) rayPayloadEXT celPayload cel;


layout(binding = 0, set = 1) uniform CameraProperties
{
  mat4 view;
  mat4 proj;
  mat4 viewInverse;
  mat4 projInverse;
}
cam;

layout(binding = 10, set = 1) buffer HitInfoInfo
{
  HitInfo h[];
}
HitInfos;

layout(push_constant) uniform Constants
{
  vec4  clearColor;
  vec4  lightColor;
  vec4  lightPosition;
  int   numObjs;
  int   numAreaSamples;
  int   frame;
  int   numSamples;
  float fuzzyAngle;
  float ior;
  int   numAreaLights;
  int   maxBounces;
  float maxRussian;
  int   numPointLights;
  int   numIds;
  int   celsteps;
  float celramp;
  float r;
  float cut;
  float maxillum;
  int   obid;
  int   pass;
  int   width;
}
pushC;


const float gaussian_k[25] = {0.024, 0.034, 0.038, 0.034, 0.024, 0.034, 0.049, 0.055, 0.049,
                              0.034, 0.038, 0.055, 0.063, 0.055, 0.038, 0.034, 0.049, 0.055,
                              0.049, 0.034, 0.024, 0.034, 0.038, 0.034, 0.024};


const float sobel_x[9] = {1, 0, -1, 2, 0, -2, 1, 0, -1};

const float sobel_y[9] = {1, 2, 1, 0, 0, 0, -1, -2, -1};

const float just_scalingx[9] = {0, 0, 0, -1, 0, 1, 0, 0, 0};

const float just_scalingy[9] = {0, -1, 0, 0, 0, 0, 0, 1, 0};

void main()
{

  uint mask = 0;
  // Initialize the random number
  prd.seed       = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, pushC.frame);
  vec3 hitValues = vec3(0);


  const float r1 = rnd(prd.seed);
  const float r2 = rnd(prd.seed);
  // Subpixel jitter: send the ray through a different position inside the pixel
  // each time, to provide antialiasing.
  const vec2 subpixel_jitter = pushC.frame == 0 ? vec2(0.5f, 0.5f) : vec2(r1, r2);

  const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + subpixel_jitter;
  const vec2 inUV        = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
  const vec2 d           = inUV * 2.0 - 1.0;

  vec4 origin    = cam.viewInverse * vec4(0, 0, 0, 1);
  vec4 target    = cam.projInverse * vec4(d.x, d.y, 1, 1);
  vec4 direction = cam.viewInverse * vec4(normalize(target.xyz), 0);

  uint  rayFlags    = gl_RayFlagsOpaqueEXT;
  float tMin        = 0.001;
  float tMax        = 10000.0;
  prd.done          = false;
  prd.weight        = vec3(1);
  prd.last_bsdf_pdf = 1.0;
  prd.specular      = true;
  prd.first         = true;
  prd.rayOrigin     = origin.xyz;
  prd.rayDirection  = direction.xyz;
  prd.photons       = false;
  prd.color         = vec3(0, 0, 0);
  prd.gnrm          = vec3(0);
  prd.snrm          = vec3(0);

  vec2 m[9] = vec2[](vec2(-pushC.r, pushC.r), vec2(0, pushC.r), vec2(pushC.r, pushC.r),
                     vec2(-pushC.r, 0), vec2(0, 0), vec2(pushC.r, 0), vec2(-pushC.r, -pushC.r),
                     vec2(0, -pushC.r), vec2(pushC.r, -pushC.r));


  vec4  c[9];
  float outlines = 1;
  vec4  weight;


  for(int i = 0; i <= 32 && !prd.done; i++)
  {
    origin.xyz    = prd.rayOrigin;
    direction.xyz = prd.rayDirection;
    weight        = vec4(prd.weight, 1);

    if(false)
    {

      traceRayEXT(topLevelAS,     // acceleration structure
                  rayFlags,       // rayFlags
                  0xFF,           // cullMask
                  1,              // sbtRecordOffset
                  0,              // sbtRecordStride
                  2,              // missIndex
                  origin.xyz,     // ray origin
                  tMin,           // ray min range
                  direction.xyz,  // ray direction
                  tMax,           // ray max range
                  1               // payload (location = 1)
      );

      c[4] = vec4(cel.normal, cel.depth);


      int ids = cel.object;
      mask    = cel.celid;


      LocalCoords local = gen_local_coords(normalize(direction.xyz));
      for(int j = 0; j < 9 && i == 0; j++)
      {
        if(j == 4)
        {
          continue;
        }


        vec4 o = vec4(origin.xyz + m[j].x * local.t + m[j].y * local.bt, origin.w);
        traceRayEXT(topLevelAS,     // acceleration structure
                    rayFlags,       // rayFlags
                    mask,           // cullMask
                    1,              // sbtRecordOffset
                    0,              // sbtRecordStride
                    2,              // missIndex
                    o.xyz,          // ray origin
                    tMin,           // ray min range
                    direction.xyz,  // ray direction
                    tMax,           // ray max range
                    1               // payload (location = 0)
        );
        c[j] = vec4(cel.normal, cel.depth);

        outlines *= float(ids == cel.object);
        ids = cel.object;
      }

      vec4 devx = vec4(0);
      vec4 devy = vec4(0);
      if(true)
      {
        int w_k = 3;
        int h_k = 3;
        int a   = ((w_k + 1) / 2) - 1;
        int b   = ((h_k + 1) / 2) - 1;


        for(int l = 0; l < h_k; l++)
        {
          for(int k = 0; k < w_k; k++)
          {
            float kernelpixx = sobel_x[(l * w_k) + k];
            float kernelpixy = sobel_y[(l * w_k) + k];
            devx += kernelpixx * c[(l * w_k) + k];
            devy += kernelpixy * c[(l * w_k) + k];
          }
        }


        vec4 mag = sqrt(devx * devx + devy * devy);
        mag      = step(pushC.cut, mag);

        outlines *= (1 - mag.r) * (1 - mag.g) * (1 - mag.b) * (1 - mag.a);
      }
    }

    if(outlines <= 0.01)
    {
      HitInfos.h[pushC.width * gl_LaunchIDEXT.y + gl_LaunchIDEXT.x] =
          HitInfo(vec4(0, 0, 0, intBitsToFloat(1)), vec4(0), vec4(0), vec4(0), vec4(0), vec4(0),
                  vec4(0), 0);
      return;
    }


    traceRayEXT(topLevelAS,     // acceleration structure
                rayFlags,       // rayFlags
                0xFF,           // cullMask
                2,              // sbtRecordOffset
                0,              // sbtRecordStride
                0,              // missIndex
                origin.xyz,     // ray origin
                tMin,           // ray min range
                direction.xyz,  // ray direction
                tMax,           // ray max range
                0               // payload (location = 0)
    );
    if(prd.photons)
    {

      HitInfos.h[pushC.width * gl_LaunchIDEXT.y + gl_LaunchIDEXT.x] =
          HitInfo(vec4(prd.rayOrigin, 1), vec4(prd.gnrm, 1), vec4(prd.snrm, 1), direction,
                  vec4(prd.rayDirection, 1), vec4(prd.color, 1), weight, prd.material);
      imageStore(
          image, ivec2(gl_LaunchIDEXT.xy),
          vec4((HitInfos.h[pushC.width * gl_LaunchIDEXT.y + gl_LaunchIDEXT.x].snrm.xyz + vec3(1))
                   / 2,
               1));
    }
    else
    {
      imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(vec3(0), 1));
    }
  }
  return;
}
